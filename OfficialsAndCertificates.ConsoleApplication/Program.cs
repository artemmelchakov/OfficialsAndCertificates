// See https://aka.ms/new-console-template for more information
Console.WriteLine("Результат:");

//Зависимость между чиновниками - {1, [2]}, { 2,[3,4]} (т.е.первый чиновник чтобы дать справку требует справку от второго,
//а второй от третьего и четвертого).
//Допустимы ответы:
//{ 3, 4, 2, 1}
//{ 4, 3, 2, 1}

//TODO!!! Обязательно найти алгоритм, который проверяет на отсутствие циклов в связях. В графах с циклами нельзя решить задачу!

// Опишем зависимость узлов в виде словаря, где Key - это id узла, а Value - массив узлов-зависимостей.
var nodeDependencyDictionary = new Dictionary<uint, uint[]> 
{
    { 1, [2] }, 
    { 2, [3, 4] }
};

//Необходимо найти узлы, из которых вообще не выходит стрелок.
//Как?
//
//Их нет в массиве узлов-зависимостей.
//




// Результирующий стек. Сюда приходят первыми значения тех узлов, которые должны быть выведены последними.
var resultStack = new Stack<uint>();

while (true)
{
    //В теории графов, узел графа, в который входят связи, но не выходят, называется вершиной с входящими дугами (англ. source node).
    //Получим список таких узлов.
    var sourceNodes = nodeDependencyDictionary.Values.SelectMany(v => v).Distinct();
    //В теории графов, узел графа, из которого не выходят связи, а только входят, называется стоком (англ. sink).
    //Получим список таких узлов.
    var sinkNodes = nodeDependencyDictionary.Keys.Except(sourceNodes).ToList();
    // Добавляем выявленные стоки в результирующий список.
    sinkNodes.ForEach(resultStack.Push);

    // Если количество стоков не равно количеству пар в словаре,
    // это означает, что можно убрать из словаря эти стоки и продолжить алгоритм.
    if (sinkNodes.Count != nodeDependencyDictionary.Count)
    {
        // Убираем из словаря стоки 
        sinkNodes.ForEach(sink => nodeDependencyDictionary.Remove(sink));
    }
    // Если же количество стоков равно количеству пар в словаре, то остались только последние стоки и вершины с входящими в них дугами.
    // Их следует записать в стек и закончить алгоритм - все узлы будут лежать в нём отсортированными необходимым нам способом.
    else 
    {
        // Запишем оставшие узлы (а остались только вершины с входящими дугами) в стек
        sourceNodes.ToList().ForEach(resultStack.Push);
        break; 
    }
}

while (resultStack.Count > 0)
{
    Console.Write(resultStack.Pop() + " ");
}

Console.ReadKey(true);